//@version=5
indicator(title="Optimus", overlay=true, max_boxes_count=500, max_lines_count=500)

// --- External dependency used ONLY for the ML-style trend line (kernel regression)
import jdehorty/KernelFunctions/2 as kernels
import jdehorty/MLExtensions/2 as ml

// ============================================================================
// CORE SETTINGS (code-only; no user inputs)
// ============================================================================
// UT Bot
float a = 2.0      // sensitivity
int   c = 10       // ATR period
bool  h = false    // Heikin Ashi source toggle (kept code-only)

// Supertrend
int   stAtrPeriod = 10
float stFactor    = 3.0

// Braid Filter (used ONLY to draw boxes when state is GRAY)
string bfMaType            = "EMA"
int    bfPeriod1           = 3
int    bfPeriod2           = 7
int    bfPeriod3           = 14
float  bfPipsMinSepPercent = 40.0

// Box styling for "dead" (gray braid) zones
color  bfBoxFill   = color.new(color.gray, 88)
color  bfBoxBorder = color.new(color.gray, 65)

// ============================================================================
// BOT CALCS
// ============================================================================
xATR  = ta.atr(c)
nLoss = a * xATR

src = h ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close, lookahead=barmerge.lookahead_off) : close

var float xATRTrailingStop = na
xATRTrailingStop := (src > nz(xATRTrailingStop[1], 0.0) and src[1] > nz(xATRTrailingStop[1], 0.0)) ? math.max(nz(xATRTrailingStop[1]), src - nLoss) :
     (src < nz(xATRTrailingStop[1], 0.0) and src[1] < nz(xATRTrailingStop[1], 0.0)) ? math.min(nz(xATRTrailingStop[1]), src + nLoss) :
     (src > nz(xATRTrailingStop[1], 0.0)) ? (src - nLoss) : (src + nLoss)

ema1  = ta.ema(src, 1)
above = ta.crossover(ema1, xATRTrailingStop)
below = ta.crossover(xATRTrailingStop, ema1)

buy  = src > xATRTrailingStop and above
sell = src < xATRTrailingStop and below

barbuy  = src > xATRTrailingStop
barsell = src < xATRTrailingStop

// ============================================================================
// BIG TREND
// ============================================================================
stAtr  = ta.atr(stAtrPeriod)
stUp   = hl2 - (stFactor * stAtr)
stDown = hl2 + (stFactor * stAtr)

var float stTrendUp = na
stTrendUp := close[1] > nz(stTrendUp[1]) ? math.max(stUp, nz(stTrendUp[1])) : stUp

var float stTrendDown = na
stTrendDown := close[1] < nz(stTrendDown[1]) ? math.min(stDown, nz(stTrendDown[1])) : stDown

var int trend = 1
trend := nz(trend[1], 1)
trend := (trend == -1 and close > nz(stTrendDown[1])) ? 1 :
         (trend == 1 and close < nz(stTrendUp[1])) ? -1 :
         trend

supertrend = trend == 1 ? stTrendUp : stTrendDown

// Offset multipliers
stOffset1 = stAtr * 0.3
stOffset2 = stAtr * 0.6
stOffset3 = stAtr * 0.9
stOffset4 = stAtr * 1.2

// ============================================================================
// CONSOLODATION ZONES
// ============================================================================

bfMa01 = ta.ema(close, bfPeriod1)
bfMa02 = ta.ema(open,  bfPeriod2)
bfMa03 = ta.ema(close, bfPeriod3)

bfMax = math.max(math.max(bfMa01, bfMa02), bfMa03)
bfMin = math.min(math.min(bfMa01, bfMa02), bfMa03)
bfDif = bfMax - bfMin

bfFilter = ta.atr(14) * bfPipsMinSepPercent / 100.0

// Original color logic:
// green: ma01 > ma02 and dif > filter
// red:   ma02 > ma01 and dif > filter
// gray:  otherwise
bfIsGray = not ( (bfMa01 > bfMa02 and bfDif > bfFilter) or (bfMa02 > bfMa01 and bfDif > bfFilter) )

// ============================================================================
// BOXES 
// ============================================================================
var box  bfBox      = na
var bool bfActive   = false
var int  bfStartBar = na
var float bfRunHigh = na
var float bfRunLow  = na

if bfIsGray and not bfActive
    bfActive   := true
    bfStartBar := bar_index
    bfRunHigh  := high
    bfRunLow   := low
    bfBox := box.new(bfStartBar, bfRunHigh, bar_index, bfRunLow, bgcolor=bfBoxFill, border_color=bfBoxBorder)

if bfIsGray and bfActive and not na(bfBox)
    bfRunHigh := math.max(bfRunHigh, high)
    bfRunLow  := math.min(bfRunLow, low)
    box.set_left(bfBox, bfStartBar)
    box.set_right(bfBox, bar_index)
    box.set_top(bfBox, bfRunHigh)
    box.set_bottom(bfBox, bfRunLow)

if (not bfIsGray) and bfActive
    // End the current gray zone; leave the box on chart
    bfActive   := false
    bfStartBar := na
    bfRunHigh  := na
    bfRunLow   := na
    bfBox      := na

// ============================================================================
// SIGNAL DOTS
// ============================================================================

// QQE Parameters (code-only)
int   qqeRsiPeriod = 14
int   qqeSF        = 5
float qqeFactor    = 4.238
int   qqeThreshold = 10  // kept for parity; not used in original signal logic

qqeSrc = close
qqeWildersPeriod = qqeRsiPeriod * 2 - 1

qqeRsi   = ta.rsi(qqeSrc, qqeRsiPeriod)
qqeRsiMa = ta.ema(qqeRsi, qqeSF)
qqeAtrRsi = math.abs(qqeRsiMa[1] - qqeRsiMa)
qqeMaAtrRsi = ta.ema(qqeAtrRsi, qqeWildersPeriod)
qqeDar = ta.ema(qqeMaAtrRsi, qqeWildersPeriod) * qqeFactor

var float qqeLongBand  = na
var float qqeShortBand = na
var int   qqeTrend     = 0

qqeDeltaFastAtrRsi = qqeDar
qqeRSIndex = qqeRsiMa

qqeNewShortBand = qqeRSIndex + qqeDeltaFastAtrRsi
qqeNewLongBand  = qqeRSIndex - qqeDeltaFastAtrRsi

qqeLongBand := (qqeRSIndex[1] > nz(qqeLongBand[1]) and qqeRSIndex > nz(qqeLongBand[1])) ? math.max(nz(qqeLongBand[1]), qqeNewLongBand) : qqeNewLongBand
qqeShortBand := (qqeRSIndex[1] < nz(qqeShortBand[1]) and qqeRSIndex < nz(qqeShortBand[1])) ? math.min(nz(qqeShortBand[1]), qqeNewShortBand) : qqeNewShortBand

qqeCross1 = ta.cross(qqeLongBand[1], qqeRSIndex)
qqeTrend := ta.cross(qqeRSIndex, qqeShortBand[1]) ? 1 : qqeCross1 ? -1 : nz(qqeTrend[1], 1)
qqeFastAtrRsiTL = qqeTrend == 1 ? qqeLongBand : qqeShortBand

// Count crosses
var int qqeXLong  = 0
var int qqeXShort = 0
qqeXLong  := qqeFastAtrRsiTL < qqeRSIndex ? (qqeXLong + 1) : 0
qqeXShort := qqeFastAtrRsiTL > qqeRSIndex ? (qqeXShort + 1) : 0

qqeLongSignal  = qqeXLong == 1
qqeShortSignal = qqeXShort == 1

// Plot as DOTS (requested): blue dot for long, red dot for short
plotshape(qqeLongSignal,  title="Long Dot",  style=shape.circle, location=location.belowbar, color=color.blue, size=size.tiny)
plotshape(qqeShortSignal, title="Short Dot", style=shape.circle, location=location.abovebar, color=color.red,  size=size.tiny)

// ============================================================================
// EMA
// ============================================================================
ema200 = ta.ema(close, 200)
plot(ema200, title="EMA", color=color.purple, linewidth=1)

// ============================================================================
// ML SMALL TREND
// ============================================================================

// Kernel settings (code-only)
float kSrc = close
int   kLookback = 8          // lookback window
float kRelWeight = 8.0       // relative weighting
int   kRegLevel = 25         // regression level
int   kLag = 2               // lag for crossover smoothing
bool  kUseSmoothing = false  // if true uses yhat2 vs yhat1 smoothing

color kGreen = color.new(color.blue, 0)
color kRed   = color.new(#CC3311, 20)

kYhat1 = kernels.rationalQuadratic(kSrc, kLookback, kRelWeight, kRegLevel)
kYhat2 = kernels.gaussian(kSrc, kLookback - kLag, kRegLevel)

// Rate-of-change coloring (default in original when smoothing is off)
wasBearRate = kYhat1[2] > kYhat1[1]
wasBullRate = kYhat1[2] < kYhat1[1]
isBearRate  = kYhat1[1] > kYhat1
isBullRate  = kYhat1[1] < kYhat1

// Smoothing coloring (when enabled)
isBullSmooth = kYhat2 >= kYhat1
isBearSmooth = kYhat2 <= kYhat1

kLineColor = kUseSmoothing ? (isBullSmooth ? kGreen : kRed) : (isBullRate ? kGreen : kRed)

plot(kYhat1, title="SMALL TREND", color=kLineColor, linewidth=2)

// ============================================================================
// ML BUY/SELL TRIANGLES (extracted feature only)
// ============================================================================

// --- Lorentzian ML settings (code-only)
float mlSrc = close
int   mlNeighborsCount = 8
int   mlMaxBarsBack    = 2000
int   mlFeatureCount   = 5

// Filters (code-only; mirrors defaults from the source script)
bool  mlUseVolatilityFilter = true
bool  mlUseRegimeFilter     = true
bool  mlUseAdxFilter        = false
float mlRegimeThreshold     = -0.1
int   mlAdxThreshold        = 20

// Feature engineering (code-only; mirrors defaults from the source script)
string f1_string = "RSI"  
int    f1_paramA = 14
int    f1_paramB = 1
string f2_string = "WT"
int    f2_paramA = 10
int    f2_paramB = 11
string f3_string = "CCI"
int    f3_paramA = 20
int    f3_paramB = 1
string f4_string = "ADX"
int    f4_paramA = 20
int    f4_paramB = 2
string f5_string = "RSI"
int    f5_paramA = 9
int    f5_paramB = 1

// Direction labels
int dirLong = 1
int dirShort = -1
int dirNeutral = 0

// Helper: normalized feature series
series_from(string feature_string, float _close, float _high, float _low, float _hlc3, int pA, int pB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, pA, pB)
        "WT"  => ml.n_wt(_hlc3, pA, pB)
        "CCI" => ml.n_cci(_close, pA, pB)
        "ADX" => ml.n_adx(_high, _low, _close, pA)

// Current feature values
f1 = series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB)
f2 = series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB)
f3 = series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB)
f4 = series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB)
f5 = series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)

// Store historical feature values in arrays (training data)
var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()
array.push(f1Array, f1)
array.push(f2Array, f2)
array.push(f3Array, f3)
array.push(f4Array, f4)
array.push(f5Array, f5)

// Lorentzian distance (featureCount fixed to 5 here)
get_lorentzian_distance(int i) => math.log(1 + math.abs(f1 - array.get(f1Array, i))) + math.log(1 + math.abs(f2 - array.get(f2Array, i))) + math.log(1 + math.abs(f3 - array.get(f3Array, i))) + math.log(1 + math.abs(f4 - array.get(f4Array, i))) + math.log(1 + math.abs(f5 - array.get(f5Array, i)))

// Training label: direction over next 4 bars (hardcoded to 4 as in source)
y_train_series = mlSrc[4] < mlSrc ? dirShort : (mlSrc[4] > mlSrc ? dirLong : dirNeutral)
var y_train_array = array.new_int()
array.push(y_train_array, y_train_series)

// Filters (same functions as source)
filterVol = ml.filter_volatility(1, 10, mlUseVolatilityFilter)
filterReg = ml.regime_filter(ohlc4, mlRegimeThreshold, mlUseRegimeFilter)
filterAdx = ml.filter_adx(mlSrc, 14, mlAdxThreshold, mlUseAdxFilter)
filter_all = filterVol and filterReg and filterAdx

// Core ANN loop storage
var predictions = array.new_float()
var distances   = array.new_float()
var float prediction = 0.0
var int signal = dirNeutral

maxBarsBackIndex = last_bar_index >= mlMaxBarsBack ? last_bar_index - mlMaxBarsBack : 0

lastDistance = -1.0
size = math.min(mlMaxBarsBack - 1, array.size(y_train_array) - 1)
sizeLoop = math.min(mlMaxBarsBack - 1, size)

if bar_index >= maxBarsBackIndex
    for i = 0 to sizeLoop
        d = get_lorentzian_distance(i)
        // note: source uses modulo spacing of 4 bars
        if d >= lastDistance and (i % 4 != 0)
            lastDistance := d
            array.push(distances, d)
            array.push(predictions, math.round(array.get(y_train_array, i)))
            if array.size(predictions) > mlNeighborsCount
                lastDistance := array.get(distances, math.round(mlNeighborsCount * 3 / 4))
                array.shift(distances)
                array.shift(predictions)
    prediction := array.sum(predictions)

// Filtered directional signal
signal := prediction > 0 and filter_all ? dirLong : (prediction < 0 and filter_all ? dirShort : nz(signal[1]))

// Kernel filter (re-uses SMALL TREND kernel state already computed above)
mlIsBullish = kUseSmoothing ? isBullSmooth : isBullRate
mlIsBearish = kUseSmoothing ? isBearSmooth : isBearRate

// Entries (only the label feature)
isDifferentSignalType = ta.change(signal) != 0
isNewBuySignal  = (signal == dirLong)  and isDifferentSignalType
isNewSellSignal = (signal == dirShort) and isDifferentSignalType

mlStartLong = isNewBuySignal  and mlIsBullish
mlStartShort = isNewSellSignal and mlIsBearish

// Plot triangles (requested colors)
plotshape(mlStartLong,  title="ML long Buy",  style=shape.triangleup,   location=location.belowbar, color=color.blue, size=size.small, offset=0, text="BUY", textcolor=color.white)
plotshape(mlStartShort, title="ML long Sell", style=shape.triangledown, location=location.abovebar, color=color.red,  size=size.small, offset=0, text="SELL", textcolor=color.white)

// ============================================================================
// ATR BANDS
// ============================================================================

// --- TwinSmooth settings (kept code-only to match Optimus style)
int   tsSMMALen   = 24
int   tsTEMALen   = 8
int   tsEMALen    = 14
float tsAtrMult   = 1.1
int   tsAtrLen    = 14

// --- SMMA helper
F_SMMA(float _src, int _len) =>
    // Call ta.sma() every bar for consistency
    float _sma  = ta.sma(_src, _len)
    float _smma = na
    if bar_index >= _len - 1
        float _alpha = 1.0 / _len
        _smma := na(_smma[1]) ? _sma : (_src - _smma[1]) * _alpha + _smma[1]
    else
        _smma := _src
    _smma

// --- TEMA helper (Pine v5 doesn't have ta.tema on all accounts)
F_TEMA(float _src, int _len) =>
    float _ema1 = ta.ema(_src, _len)
    float _ema2 = ta.ema(_ema1, _len)
    float _ema3 = ta.ema(_ema2, _len)
    3.0 * _ema1 - 3.0 * _ema2 + _ema3

// Base calculation
float tsSmma      = F_SMMA(close, tsSMMALen)
float tsTema      = F_TEMA(close, tsTEMALen)
float tsBase      = (tsSmma + tsTema) / 2.0
float tsTrendBase = ta.ema(tsBase, tsEMALen)

// ATR bands
float tsAtr   = ta.atr(tsAtrLen)
float tsUpper = tsTrendBase + tsAtr * tsAtrMult
float tsLower = tsTrendBase - tsAtr * tsAtrMult

// State (QB): 1 = bullish, -1 = bearish, else keep prior
bool tsLongC  = close > tsUpper
bool tsShortC = close < tsLower

var int tsQB = 0
if tsShortC
    tsQB := -1
else if tsLongC and not tsShortC
    tsQB := 1
else
    tsQB := nz(tsQB[1], 0)

color tsUp = color.rgb(0, 221, 255)
color tsDn = color.rgb(219, 77, 12)
color tsNu = color.gray
color tsColor = tsQB == 1 ? tsUp : tsQB == -1 ? tsDn : tsNu

// Plot the ACTIVE band + a light fill to close (no candle override; Optimus already barcolors)
float tsActiveBand = tsQB == 1 ? tsLower : tsUpper
tsBandPlot = plot(tsActiveBand, title="ATR BANDS", color=color.new(tsColor, 15), linewidth=1)
tsClosePlot = plot(close, title="Close", display=display.none)
fill(tsBandPlot, tsClosePlot, color=color.new(tsColor, 82))


// ============================================================================
// PLOTTING (your original Optimus visuals)
// ============================================================================
plotshape(buy,  title="LONG",  text="long",  style=shape.labelup,   location=location.belowbar, color=color.blue, textcolor=color.white, size=size.auto)
plotshape(sell, title="SHORT", text="short", style=shape.labeldown, location=location.abovebar, color=color.red,  textcolor=color.white, size=size.auto)

barcolor(barbuy  ? color.blue : na)
barcolor(barsell ? color.red  : na)

stColor = trend == 1 ? color.blue : color.red
plot(supertrend, title="BIG TREND", color=stColor, linewidth=3, style=plot.style_linebr)

bullLine1 = trend == 1 ? supertrend + stOffset1 : na
bullLine2 = trend == 1 ? supertrend + stOffset2 : na
bullLine3 = trend == 1 ? supertrend + stOffset3 : na
bullLine4 = trend == 1 ? supertrend + stOffset4 : na

bearLine1 = trend == -1 ? supertrend - stOffset1 : na
bearLine2 = trend == -1 ? supertrend - stOffset2 : na
bearLine3 = trend == -1 ? supertrend - stOffset3 : na
bearLine4 = trend == -1 ? supertrend - stOffset4 : na

plot(bullLine1, title="Bull 1", color=color.new(color.blue, 20), linewidth=2, style=plot.style_linebr)
plot(bullLine2, title="Bull 2", color=color.new(color.blue, 40), linewidth=2, style=plot.style_linebr)
plot(bullLine3, title="Bull 3", color=color.new(color.blue, 60), linewidth=1, style=plot.style_linebr)
plot(bullLine4, title="Bull 4", color=color.new(color.blue, 80), linewidth=1, style=plot.style_linebr)

plot(bearLine1, title="Bear 1", color=color.new(color.red, 30), linewidth=2, style=plot.style_linebr)
plot(bearLine2, title="Bear 2", color=color.new(color.red, 50), linewidth=2, style=plot.style_linebr)
plot(bearLine3, title="Bear 3", color=color.new(color.red, 70), linewidth=1, style=plot.style_linebr)
plot(bearLine4, title="Bear 4", color=color.new(color.red, 85), linewidth=1, style=plot.style_linebr)

// Shading (hidden plots must be linebr)
pb0 = plot(trend == 1 ? supertrend : na, display=display.none, style=plot.style_linebr)
pb1 = plot(bullLine1, display=display.none, style=plot.style_linebr)
pb2 = plot(bullLine2, display=display.none, style=plot.style_linebr)
pb3 = plot(bullLine3, display=display.none, style=plot.style_linebr)
pb4 = plot(bullLine4, display=display.none, style=plot.style_linebr)

fill(pb0, pb1, color=color.new(color.blue, 92))
fill(pb1, pb2, color=color.new(color.blue, 95))
fill(pb2, pb3, color=color.new(color.blue, 97))
fill(pb3, pb4, color=color.new(color.blue, 98))

ps0 = plot(trend == -1 ? supertrend : na, display=display.none, style=plot.style_linebr)
ps1 = plot(bearLine1, display=display.none, style=plot.style_linebr)
ps2 = plot(bearLine2, display=display.none, style=plot.style_linebr)
ps3 = plot(bearLine3, display=display.none, style=plot.style_linebr)
ps4 = plot(bearLine4, display=display.none, style=plot.style_linebr)

fill(ps0, ps1, color=color.new(color.red, 92))
fill(ps1, ps2, color=color.new(color.red, 95))
fill(ps2, ps3, color=color.new(color.red, 97))
fill(ps3, ps4, color=color.new(color.red, 98))

